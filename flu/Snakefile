import datetime


wildcard_constraints:
    flu_type="[A-Za-z0-9]+",
    segment="\d",
    year="\d\d\d\d",
    strain="[^_/]+",
    segment_name="[^_/]+",
    reference="[^_/]+",


def segment_number(segment_name):
    return "4"


rule download_clades:
    message:
        "Downloading clade definitions for {wildcards.strain} from {params.source} -> {output}"
    output:
        "data/clades_{strain}_{segment_name}_{reference}_raw.tsv",
    params:
        source=lambda w: config["builds"][w.strain][w.segment_name][w.reference][
            "clade_url"
        ],
    shell:
        "curl {params.source} | sed '/V1A\\tHA1\\t146\\tI/d' >{output}"


rule offset_clades:
    input:
        rules.download_clades.output,
    output:
        "data/clades_{strain}_{segment_name}_{reference}.tsv",
    params:
        offset=lambda w: config["builds"][w.strain][w.segment_name][w.reference][
            "clade_offset"
        ],
    shell:
        """
        perl -F'\\t' -ne \
            '$F[2]+={params.offset} if $F[1] =~ "nuc"; \
            print join "\\t", @F' \
            {input} \
            >{output}
        """


rule download_includes:
    output:
        "data/includes_{strain}_{segment_name}_{reference}.tsv",
    params:
        source=lambda w: config["builds"][w.strain][w.segment_name][w.reference][
            "include_url"
        ],
    shell:
        "curl {params.source} >{output}"


rule download_excludes:
    output:
        "data/excludes_{strain}_{segment_name}_{reference}.txt",
    params:
        source=lambda w: config["builds"][w.strain][w.segment_name][w.reference][
            "exclude_url"
        ],
    shell:
        "curl {params.source} >{output}"


rule parse:
    input:
        sequences="data/{strain}/raw_{segment_name}.fasta",
    output:
        metadata="data/{strain}_{segment_name}_metadata.tsv",
        sequences="data/{strain}_{segment_name}_sequences.fasta",
    params:
        fields="strainName virus segment EPI_ISL date submission_date region country division location collecting_lab submitting_lab age sex",
    shell:
        """
        augur parse \
            --sequences {input.sequences} \
            --fields {params.fields} \
            --output-metadata {output.metadata} \
            --output-sequences {output.sequences}
        """


genes = ["SigPep", "HA1", "HA2"]


rule subsample:
    input:
        aligned_sequences=rules.parse.output.sequences,
        enriched_metadata=rules.parse.output.metadata,
        include_accessions="data/includes_{strain}_{segment_name}_{reference}.tsv",
    output:
        sampled_sequences="build/{strain}/{segment_name}/{reference}/subsample_raw.fasta",
        sampled_strains="build/{strain}/{segment_name}/{reference}/subsample_raw.txt",
    params:
        filter_arguments=lambda w: config["builds"][w.strain][w.segment_name][
            w.reference
        ]["filter"],
        reference_EPI_ISL=lambda w: config["builds"][w.strain][w.segment_name][
            w.reference
        ]["reference_EPI_ISL"],
    shell:
        """
        augur filter \
            --sequences {input.aligned_sequences} \
            --metadata {input.enriched_metadata} \
            --include {input.include_accessions} \
            --include-where EPI_ISL={params.reference_EPI_ISL} \
            {params.filter_arguments} \
            --output {output.sampled_sequences} \
            --output-strains {output.sampled_strains}
        """


rule remove_duplicates:
    input:
        rules.subsample.output.sampled_sequences,
    output:
        sequences="build/{strain}/{segment_name}/{reference}/subsample_ex_duplicates.fasta",
    shell:
        """
        seqkit grep -ivr -p '-egg' {input} | \
        seqkit rmdup -sP - >{output}
        """


rule exclude_outliers:
    input:
        sequences=rules.remove_duplicates.output.sequences,
        enriched_metadata=rules.parse.output.metadata,
        exclude="profiles/exclude.txt",
        exclude_specific=rules.download_excludes.output,
    output:
        sampled_sequences="build/{strain}/{segment_name}/{reference}/subsample_ex_ref.fasta",
        sampled_strains="build/{strain}/{segment_name}/{reference}/subsample_ex_ref.txt",
    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.enriched_metadata} \
            --exclude {input.exclude} {input.exclude_specific}\
            --min-date 2016 \
            --output {output.sampled_sequences} \
            --output-strains {output.sampled_strains}
        """


rule add_reference:
    input:
        sample=rules.exclude_outliers.output.sampled_sequences,
        reference="references/{strain}/{segment_name}/{reference}/reference.fasta",
    output:
        "build/{strain}/{segment_name}/{reference}/subsample.fasta",
    params:
        first_line=lambda w: f">{w.reference}",
    shell:
        """
        tail -n +2 {input.reference} | \
        cat <(echo {params.first_line:q}) - {input.sample} >{output}
        """


rule align:
    input:
        sequences=rules.add_reference.output,
        genemap="references/{strain}/{segment_name}/{reference}/genemap.gff",
        reference="references/{strain}/{segment_name}/{reference}/reference.fasta",
    output:
        alignment="build/{strain}/{segment_name}/{reference}/align.aligned.fasta",
        insertions="build/{strain}/{segment_name}/{reference}/align.insertions.csv",
    params:
        outdir=lambda w: f"build/{w.strain}/{w.segment_name}/{w.reference}/aligned.gene.{{gene}}.fasta",
    threads: 3
    shell:
        """
        nextalign run \
            --jobs={threads} \
            --input-ref {input.reference} \
            --input-gene-map {input.genemap} \
            {input.sequences} \
            --output-translations {params.outdir} \
            --output-fasta {output.alignment} \
            --output-insertions {output.insertions} \
            2>&1
        """


rule tree:
    input:
        alignment=rules.align.output.alignment,
    output:
        tree="build/{strain}/{segment_name}/{reference}/tree_raw.nwk",
    params:
        args=lambda w: config["tree"].get("tree-builder-args", "")
        if "tree" in config
        else "",
    threads: 3
    shell:
        """
        augur tree \
            --alignment {input.alignment} \
            --tree-builder-args {params.args} \
            --output {output.tree} \
            --nthreads {threads} \
            > /dev/null
        """


rule refine:
    input:
        tree=rules.tree.output.tree,
        alignment=rules.align.output.alignment,
        enriched_metadata=rules.parse.output.metadata,
    output:
        tree="build/{strain}/{segment_name}/{reference}/tree.nwk",
        node_data="build/{strain}/{segment_name}/{reference}/branch_lengths.json",
    threads: 1
    shell:
        """
        augur refine \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --metadata {input.enriched_metadata} \
            --output-tree {output.tree} \
            --output-node-data {output.node_data} \
            --root {wildcards.reference} \
            --divergence-unit mutations-per-site
        """


rule ancestral:
    message:
        """
        Reconstructing ancestral sequences and mutations
          - inferring ambiguous mutations
        """
    input:
        tree=rules.refine.output.tree,
        alignment=rules.align.output.alignment,
    output:
        node_data="build/{strain}/{segment_name}/{reference}/nt_muts.json",
    params:
        inference="joint",
    shell:
        """
        augur ancestral \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --output-node-data {output.node_data} \
            --inference {params.inference} \
            --infer-ambiguous \
            > /dev/null
        """


rule aa_muts_explicit:
    message:
        "Translating amino acid sequences"
    input:
        translations=rules.align.output.alignment,
        tree=rules.refine.output.tree,
        genemap="references/{strain}/{segment_name}/{reference}/genemap.gff",
        reference="references/{strain}/{segment_name}/{reference}/reference.fasta",
    output:
        node_data="build/{strain}/{segment_name}/{reference}/aa_muts_explicit.json",
    params:
        genes=["SigPep", "HA1", "HA2"],
        translations=lambda w: expand(
            "build/{strain}/{segment_name}/{reference}/aligned.gene.{genes}.fasta",
            strain=w.strain,
            segment_name=w.segment_name,
            genes=["SigPep", "HA1", "HA2"],
            reference=w.reference,
        ),
    shell:
        """
        python3 scripts/explicit_translation.py \
            --tree {input.tree} \
            --annotation {input.genemap} \
            --reference {input.reference} \
            --translations {params.translations:q} \
            --genes {params.genes} \
            --output {output.node_data} \
            > /dev/null
        """


rule clades:
    message:
        "Adding internal clade labels"
    input:
        tree=rules.refine.output.tree,
        aa_muts=rules.aa_muts_explicit.output.node_data,
        nuc_muts=rules.ancestral.output.node_data,
        clades=rules.offset_clades.output,
    output:
        node_data="build/{strain}/{segment_name}/{reference}/clades.json",
    shell:
        """
        augur clades --tree {input.tree} \
            --mutations {input.nuc_muts} {input.aa_muts} \
            --clades {input.clades} \
            --output-node-data {output.node_data} \
            > /dev/null
        """


def node_data(w):
    nodes = ["ancestral", "refine", "aa_muts_explicit"]

    if w.segment_name == "ha":
        nodes.extend(["clades"])
    return nodes


rule export:
    message:
        "Exporting data files for auspice"
    input:
        tree=rules.refine.output.tree,
        metadata=rules.parse.output.metadata,
        node_data=lambda w: [
            rules.__dict__[rule].output.node_data for rule in node_data(w)
        ],
        auspice_config=lambda w: config["files"]["auspice_config"],
    output:
        auspice_json="auspice/{strain}/{segment_name}/{reference}/auspice_raw.json",
    params:
        fields="region strainName country date EPI_ISL",
        date=datetime.datetime.utcnow().strftime("%Y-%m-%d"),
    shell:
        """
        AUGUR_RECURSION_LIMIT=10000 \
        augur export v2 \
            --tree {input.tree} \
            --metadata {input.metadata} \
            --node-data {input.node_data}\
            --auspice-config {input.auspice_config} \
            --color-by-metadata {params.fields} \
            --title "Nextclade reference tree for Influenza type:{wildcards.strain} segment:{wildcards.segment_name} with root {wildcards.reference} built on {params.date}" \
            --output {output.auspice_json} 2>&1;
        """


rule swap_strain_accession:
    input:
        auspice_json="auspice/{strain}/{segment_name}/{reference}/auspice_raw.json",
    output:
        auspice_json="auspice/{strain}/{segment_name}/{reference}/auspice.json",
    shell:
        """
        python3 scripts/swap_strain_accession.py \
            --tree-input-path {input.auspice_json} \
            --tree-output-path {output.auspice_json}
        """


rule generate_sample_sequences:
    input:
        sequences="data/{strain}_{segment_name}_sequences.fasta",
        metadata=rules.parse.output.metadata,
    output:
        sequences="build/{strain}/{segment_name}/{reference}/sample_sequences.fasta",
    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --min-date 2020 --group-by year --subsample-max-sequences 50  \
            --exclude-ambiguous-dates-by year \
            --exclude-where 'country!=USA' \
            --probabilistic-sampling \
            --output {output.sequences}
        """


rule assemble_folder:
    input:
        genemap="references/{strain}/{segment_name}/{reference}/genemap.gff",
        reference="references/{strain}/{segment_name}/{reference}/reference.fasta",
        virus_properties="references/{strain}/{segment_name}/{reference}/virus_properties.json",
        sample_sequences="build/{strain}/{segment_name}/{reference}/sample_sequences.fasta",
        tree="auspice/{strain}/{segment_name}/{reference}/auspice.json",
        qc="profiles/qc.json",
        tag="profiles/tag.json",
        primers="profiles/primers.csv",
    output:
        genemap="output/flu_{strain}_{segment_name}/references/{reference}/versions/{timestamp}/files/genemap.gff",
        primers="output/flu_{strain}_{segment_name}/references/{reference}/versions/{timestamp}/files/primers.csv",
        virus_properties="output/flu_{strain}_{segment_name}/references/{reference}/versions/{timestamp}/files/virus_properties.json",
        qc="output/flu_{strain}_{segment_name}/references/{reference}/versions/{timestamp}/files/qc.json",
        reference="output/flu_{strain}_{segment_name}/references/{reference}/versions/{timestamp}/files/reference.fasta",
        sample_sequences="output/flu_{strain}_{segment_name}/references/{reference}/versions/{timestamp}/files/sequences.fasta",
        tree="output/flu_{strain}_{segment_name}/references/{reference}/versions/{timestamp}/files/tree.json",
        tag="output/flu_{strain}_{segment_name}/references/{reference}/versions/{timestamp}/files/tag.json",
    shell:
        """
        mkdir -p output/flu_{wildcards.strain}_{wildcards.segment_name}/references/{wildcards.reference}/versions/{wildcards.timestamp}/files/;
        jq <{input.tag} '.tag="{wildcards.timestamp}"' >{output.tag};
        cp {input.genemap} {output.genemap};
        cp {input.reference} {output.reference};
        cp {input.primers} {output.primers};
        cp {input.virus_properties} {output.virus_properties};
        cp {input.qc} {output.qc};
        cp {input.sample_sequences} {output.sample_sequences};
        cp {input.tree} {output.tree};
        """


timestamp = datetime.datetime.utcnow().isoformat()[:-7] + "Z"


rule test_nextclade:
    input:
        expand(
            "output/flu_{{strain}}_{{segment_name}}/references/{{reference}}/versions/{timestamp}/files/tree.json",
            timestamp=timestamp,
        ),
    output:
        "test/{strain}/{segment_name}/{reference}/nextclade.aligned.fasta",
    params:
        indir=expand(
            "output/flu_{{strain}}_{{segment_name}}/references/{{reference}}/versions/{timestamp}/files",
            timestamp=timestamp,
        ),
        outdir="test/{strain}/{segment_name}/{reference}",
    shell:
        """
        nextclade run \
         {params.indir}/sequences.fasta\
         --input-dataset={params.indir} \
         --output-all={params.outdir}\
         --output-tsv={params.outdir}/nextclade.tsv\
         --output-tree={params.outdir}/nextclade.auspice.json\
         --output-basename=nextclade 2>&1
        """


rule all:
    input:
        [
            f"test/{strain}/{segment_name}/{reference}/nextclade.aligned.fasta"
            for strain in config["builds"]
            for segment_name in config["builds"][strain]
            for reference in config["builds"][strain][segment_name]
        ],


rule clean:
    shell:
        """
        rm -rf output test data/clades* data/include*
        """


rule clean_all:
    shell:
        """
        rm -rf output test auspice build pre-processed data
        """
